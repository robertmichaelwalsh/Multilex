// Generated by gramex V3.0 from 'csharp language specification v1.2.raw' (this build Mar 25 2012 at 13:21:48)
// Command line: C:\csle\dev\gramex\gramex.exe -d -s csharp language specification v1.2.raw
Csharp ()(compilation_unit)

// Grammar
// This appendix contains summaries of the lexical and syntactic grammars found in the main document, and of the grammar extensions for unsafe code. Grammar productions appear here in the same order that they appear in the main document.
// A.2 Syntactic grammar
// A.2.1 Basic concepts

namespace_name                      ::= namespace_or_type_name ;

type_name                           ::= namespace_or_type_name ; 

namespace_or_type_name              ::= IDENTIFIER  |
                                     namespace_or_type_name DOT  IDENTIFIER ; // A.2.2 Types


type                                ::= value_type |
                                     reference_type ; 

value_type                          ::= struct_type |
                                     enum_type ; 

struct_type                         ::= type_name |
                                     simple_type ; 

simple_type                         ::= numeric_type |
                                     BOOL ; 

numeric_type                        ::= integral_type |
                                     floating_point_type |
                                     DECIMAL ; 

integral_type                       ::= SBYTE  |
                                     BYTE  |
                                     SHORT  |
                                     USHORT  |
                                     INT  |
                                     UINT  |
                                     LONG  |
                                     ULONG  |
                                     CHAR ; 

floating_point_type                 ::= FLOAT  |
                                     DOUBLE  ; 

enum_type                           ::= type_name ; 

reference_type                      ::= class_type |
                                     interface_type |
                                     array_type |
                                     delegate_type ; 

class_type                          ::= type_name |
                                     OBJECT  |
                                     STRING ; 

interface_type                      ::= type_name ; 

delegate_type                       ::= type_name ; // A.2.3 Variables


variable_reference                  ::= expression ; // A.2.4 Expressions


argument_list                       ::= argument |
                                     argument_list COMMA  argument ; 

argument                            ::= expression |
                                     REF  variable_reference |
                                     OUT  variable_reference ; 

primary_expression                  ::= primary_no_array_creation_expression |
                                     array_creation_expression ; 

primary_no_array_creation_expression::= literal |
                                     simple_name |
                                     parenthesized_expression |
                                     member_access |
                                     invocation_expression |
                                     element_access |
                                     this_access |
                                     base_access |
                                     post_increment_expression |
                                     post_decrement_expression |
                                     object_creation_expression |
                                     delegate_creation_expression |
                                     typeof_expression |
                                     checked_expression |
                                     unchecked_expression ; 

simple_name                         ::= IDENTIFIER ; 

parenthesized_expression            ::= LPAREN  expression RPAREN ; 

member_access                       ::= primary_expression DOT  IDENTIFIER  |
                                     predefined_type DOT  IDENTIFIER ; 

predefined_type                     ::= BOOL  |
                                     BYTE  |
                                     CHAR  |
                                     DECIMAL  |
                                     DOUBLE  |
                                     FLOAT  |
                                     INT  |
                                     LONG  |
                                     OBJECT  |
                                     SBYTE  |
                                     SHORT  |
                                     STRING  |
                                     UINT  |
                                     ULONG  |
                                     USHORT ; 

invocation_expression               ::= primary_expression LPAREN  argument_list? RPAREN ; 

element_access                      ::= primary_no_array_creation_expression LBRACKET  expression_list RBRACKET ; 

expression_list                     ::= expression |
                                     expression_list COMMA  expression ; 

this_access                         ::= THIS ; 

base_access                         ::= BASE  DOT  IDENTIFIER  |
                                     BASE  LBRACKET  expression_list RBRACKET ; 

post_increment_expression           ::= primary_expression INCREMENT ; 

post_decrement_expression           ::= primary_expression DECREMENT ; 

object_creation_expression          ::= NEW  type LPAREN  argument_list? RPAREN ; 

array_creation_expression           ::= NEW  non_array_type LBRACKET  expression_list RBRACKET  rank_specifiers? array_initializer? |
                                     NEW  array_type array_initializer ; 

delegate_creation_expression        ::= NEW  delegate_type LPAREN  expression RPAREN ; 

typeof_expression                   ::= TYPEOF  LPAREN  type RPAREN  |
                                     TYPEOF  LPAREN  VOID  RPAREN ; 

checked_expression                  ::= CHECKED  LPAREN  expression RPAREN ; 

unchecked_expression                ::= UNCHECKED  LPAREN  expression RPAREN ; 

unary_expression                    ::= primary_expression |
                                     ADD_OP  unary_expression |
                                     SUB_OP  unary_expression |
                                     NOT_OP  unary_expression |
                                     TILDE  unary_expression |
                                     pre_increment_expression |
                                     pre_decrement_expression |
                                     cast_expression ; 

pre_increment_expression            ::= INCREMENT  unary_expression ; 

pre_decrement_expression            ::= DECREMENT  unary_expression ; 

cast_expression                     ::= LPAREN  type RPAREN  unary_expression ; 

multiplicative_expression           ::= unary_expression |
                                     multiplicative_expression MUL_OP  unary_expression |
                                     multiplicative_expression DIV_OP  unary_expression |
                                     multiplicative_expression MOD_OP  unary_expression ; 

additive_expression                 ::= multiplicative_expression |
                                     additive_expression ADD_OP  multiplicative_expression |
                                     additive_expression SUB_OP  multiplicative_expression ; 

shift_expression                    ::= additive_expression |
                                     shift_expression LSHIFT_OP  additive_expression |
                                     shift_expression RSHIFT_OP  additive_expression ; 

relational_expression               ::= shift_expression |
                                     relational_expression LESSTHAN_OP  shift_expression |
                                     relational_expression GREATERTHAN_OP  shift_expression |
                                     relational_expression LESSTHANEQ_OP  shift_expression |
                                     relational_expression GREATERTHANEQ_OP  shift_expression |
                                     relational_expression IS  type |
                                     relational_expression AS  type ; 

equality_expression                 ::= relational_expression |
                                     equality_expression EQUALITY_OP  relational_expression |
                                     equality_expression NEQUALITY_OP  relational_expression ; 

and_expression                      ::= equality_expression |
                                     and_expression AND_OP  equality_expression ; 

exclusive_or_expression             ::= and_expression |
                                     exclusive_or_expression XOR_OP  and_expression ; 

inclusive_or_expression             ::= exclusive_or_expression |
                                     inclusive_or_expression OR_OP  exclusive_or_expression ; 

conditional_and_expression          ::= inclusive_or_expression |
                                     conditional_and_expression CONDAND_OP  inclusive_or_expression ; 

conditional_or_expression           ::= conditional_and_expression |
                                     conditional_or_expression CONDOR_OP  conditional_and_expression ; 

conditional_expression              ::= conditional_or_expression |
                                     conditional_or_expression QUESTION  expression COLON  expression ; 

assignment                          ::= unary_expression assignment_operator expression ; 

assignment_operator                 ::= DIRASSIGN  |
                                     ADDASSIGN  |
                                     SUBASSIGN  |
                                     MULASSIGN  |
                                     DIVASSIGN  |
                                     ANDASSIGN  |
                                     MODASSIGN  |
                                     ORASSIGN  |
                                     XORASSIGN  |
                                     LSHIFTASSIGN  |
                                     RSHIFTASSIGN  ; 

expression                          ::= conditional_expression |
                                     assignment ; 

constant_expression                 ::= expression ; 

boolean_expression                  ::= expression ; // A.2.5 Statements


statement                           ::= labeled_statement |
                                     declaration_statement |
                                     embedded_statement ; 

embedded_statement                  ::= block |
                                     empty_statement |
                                     expression_statement |
                                     selection_statement |
                                     iteration_statement |
                                     jump_statement |
                                     try_statement |
                                     checked_statement |
                                     unchecked_statement |
                                     lock_statement |
                                     using_statement ; 

block                               ::= LBRACE  statement_list? RBRACE ; 

statement_list                      ::= statement |
                                     statement_list statement ; 

empty_statement                     ::= SEMICOLON ; 

labeled_statement                   ::= IDENTIFIER  COLON  statement ; 

declaration_statement               ::= local_variable_declaration SEMICOLON  |
                                     local_constant_declaration SEMICOLON  ; 

local_variable_declaration          ::= type local_variable_declarators ; 

local_variable_declarators          ::= local_variable_declarator |
                                     local_variable_declarators COMMA  local_variable_declarator ; 

local_variable_declarator           ::= IDENTIFIER  |
                                     IDENTIFIER  DIRASSIGN  local_variable_initializer ; 

local_variable_initializer          ::= expression |
                                     array_initializer ; 

local_constant_declaration          ::= CONST  type constant_declarators ; 

constant_declarators                ::= constant_declarator |
                                     constant_declarators COMMA  constant_declarator ; 

constant_declarator                 ::= IDENTIFIER  DIRASSIGN  constant_expression ; 

expression_statement                ::= statement_expression SEMICOLON ; 

statement_expression                ::= invocation_expression |
                                     object_creation_expression |
                                     assignment |
                                     post_increment_expression |
                                     post_decrement_expression |
                                     pre_increment_expression |
                                     pre_decrement_expression ; 

selection_statement                 ::= if_statement |
                                     switch_statement ; 

if_statement                        ::= IF  LPAREN  boolean_expression RPAREN  embedded_statement |
                                     IF  LPAREN  boolean_expression RPAREN  embedded_statement ELSE  embedded_statement ; 

switch_statement                    ::= SWITCH  LPAREN  expression RPAREN  switch_block ; 

switch_block                        ::= LBRACE  switch_sections? RBRACE ; 

switch_sections                     ::= switch_section |
                                     switch_sections switch_section ; 

switch_section                      ::= switch_labels statement_list ; 

switch_labels                       ::= switch_label |
                                     switch_labels switch_label ; 

switch_label                        ::= CASE  constant_expression COLON  |
                                     DEFAULT  COLON  ; 

iteration_statement                 ::= while_statement |
                                     do_statement |
                                     for_statement |
                                     foreach_statement ; 

while_statement                     ::= WHILE  LPAREN  boolean_expression RPAREN  embedded_statement ; 

do_statement                        ::= DO  embedded_statement WHILE  LPAREN  boolean_expression RPAREN  SEMICOLON  ; 

for_statement                       ::= FOR  LPAREN  for_initializer? SEMICOLON  for_condition? SEMICOLON  for_iterator? RPAREN  embedded_statement ; 

for_initializer                     ::= local_variable_declaration |
                                     statement_expression_list ; 

for_condition                       ::= boolean_expression ; 

for_iterator                        ::= statement_expression_list ; 

statement_expression_list           ::= statement_expression |
                                     statement_expression_list COMMA  statement_expression ; 

foreach_statement                   ::= FOREACH  LPAREN  type IDENTIFIER  IN  expression RPAREN  embedded_statement ; 

jump_statement                      ::= break_statement |
                                     continue_statement |
                                     goto_statement |
                                     return_statement |
                                     throw_statement ; 

break_statement                     ::= BREAK  SEMICOLON  ; 

continue_statement                  ::= CONTINUE  SEMICOLON  ; 

goto_statement                      ::= GOTO  IDENTIFIER  SEMICOLON  |
                                     GOTO  CASE  constant_expression SEMICOLON  |
                                     GOTO  DEFAULT  SEMICOLON  ; 

return_statement                    ::= RETURN  expression? SEMICOLON  ; 

throw_statement                     ::= THROW  expression? SEMICOLON  ; 

try_statement                       ::= TRY  block catch_clauses |
                                     TRY  block finally_clause |
                                     TRY  block catch_clauses finally_clause ; 

catch_clauses                       ::= specific_catch_clauses general_catch_clause? |
                                     specific_catch_clauses? general_catch_clause ; 

specific_catch_clauses              ::= specific_catch_clause |
                                     specific_catch_clauses specific_catch_clause ; 

specific_catch_clause               ::= CATCH  LPAREN  class_type IDENTIFIER?  RPAREN  block ; 

general_catch_clause                ::= CATCH  block ; 

finally_clause                      ::= FINALLY  block ; 

checked_statement                   ::= CHECKED  block ; 

unchecked_statement                 ::= UNCHECKED  block ; 

lock_statement                      ::= LOCK  LPAREN  expression RPAREN  embedded_statement ; 

using_statement                     ::= USING  LPAREN  resource_acquisition RPAREN  embedded_statement ; 

resource_acquisition                ::= local_variable_declaration |
                                     expression ; // A.2.6 Namespaces


compilation_unit                    ::= using_directives? global_attributes? namespace_member_declarations? ; 

namespace_declaration               ::= NAMESPACE  qualified_identifier namespace_body SEMICOLON? ; 

qualified_identifier                ::= IDENTIFIER  |
                                     qualified_identifier DOT  IDENTIFIER  ; 

namespace_body                      ::= LBRACE  using_directives? namespace_member_declarations? RBRACE  ; 

using_directives                    ::= using_directive |
                                     using_directives using_directive ; 

using_directive                     ::= using_alias_directive |
                                     using_namespace_directive ; 

using_alias_directive               ::= USING  IDENTIFIER  DIRASSIGN  namespace_or_type_name SEMICOLON ; 

using_namespace_directive           ::= USING  namespace_name SEMICOLON  ; 

namespace_member_declarations       ::= namespace_member_declaration |
                                     namespace_member_declarations namespace_member_declaration ; 

namespace_member_declaration        ::= namespace_declaration |
                                     type_declaration ; 

type_declaration                    ::= class_declaration |
                                     struct_declaration |
                                     interface_declaration |
                                     enum_declaration |
                                     delegate_declaration ; // A.2.7 Classes


class_declaration                   ::= attributes? class_modifiers? CLASS  IDENTIFIER  class_base? class_body SEMICOLON?  ; 

class_modifiers                     ::= class_modifier |
                                     class_modifiers class_modifier ; 

class_modifier                      ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE  |
                                     ABSTRACT  |
                                     SEALED  ; 

class_base                          ::= COLON  class_type |
                                     COLON  interface_type_list |
                                     COLON  class_type COMMA  interface_type_list ; 

interface_type_list                 ::= interface_type |
                                     interface_type_list COMMA  interface_type ; 

class_body                          ::= LBRACE  class_member_declarations? RBRACE  ; 

class_member_declarations           ::= class_member_declaration |
                                     class_member_declarations class_member_declaration ; 

class_member_declaration            ::= constant_declaration |
                                     field_declaration |
                                     method_declaration |
                                     property_declaration |
                                     event_declaration |
                                     indexer_declaration |
                                     operator_declaration |
                                     constructor_declaration |
                                     destructor_declaration |
                                     static_constructor_declaration |
                                     type_declaration ; 

constant_declaration                ::= attributes? constant_modifiers? CONST  type constant_declarators SEMICOLON  ; 

constant_modifiers                  ::= constant_modifier |
                                     constant_modifiers constant_modifier ; 

constant_modifier                   ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE  ; 

field_declaration                   ::= attributes? field_modifiers? type variable_declarators SEMICOLON  ; 

field_modifiers                     ::= field_modifier |
                                     field_modifiers field_modifier ; 

field_modifier                      ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE  |
                                     STATIC  |
                                     READONLY  |
                                     VOLATILE ; 

variable_declarators                ::= variable_declarator |
                                     variable_declarators COMMA  variable_declarator ; 

variable_declarator                 ::= IDENTIFIER  |
                                     IDENTIFIER  DIRASSIGN  variable_initializer ; 

variable_initializer                ::= expression |
                                     array_initializer ; 

method_declaration                  ::= method_header method_body ; 

method_header                       ::= attributes? method_modifiers? return_type member_name LPAREN  formal_parameter_list? RPAREN  ; 

method_modifiers                    ::= method_modifier |
                                     method_modifiers method_modifier ; 

method_modifier                     ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE  |
                                     STATIC  |
                                     VIRTUAL  |
                                     SEALED  |
                                     OVERRIDE  |
                                     ABSTRACT  |
                                     EXTERN  ; 

return_type                         ::= type |
                                     VOID  ; 

member_name                         ::= IDENTIFIER  |
                                     interface_type DOT  IDENTIFIER  ; 

method_body                         ::= block |
                                     SEMICOLON  ; 

formal_parameter_list               ::= fixed_parameters |
                                     fixed_parameters COMMA  parameter_array |
                                     parameter_array ; 

fixed_parameters                    ::= fixed_parameter |
                                     fixed_parameters COMMA  fixed_parameter ; 

fixed_parameter                     ::= attributes? parameter_modifier? type IDENTIFIER  ; 

parameter_modifier                  ::= REF  |
                                     OUT ; 

parameter_array                     ::= attributes? PARAMS  array_type IDENTIFIER  ; 

property_declaration                ::= attributes? property_modifiers? type member_name LBRACE  accessor_declarations RBRACE ; 

property_modifiers                  ::= property_modifier |
                                     property_modifiers property_modifier ; 

property_modifier                   ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     STATIC  |
                                     PRIVATE  |
                                     VIRTUAL  |
                                     SEALED  |
                                     OVERRIDE  |
                                     ABSTRACT |
                                     EXTERN ; 

accessor_declarations               ::= get_accessor_declaration set_accessor_declaration? |
                                     set_accessor_declaration get_accessor_declaration? ; 

get_accessor_declaration            ::= attributes? GET  accessor_body ; 

set_accessor_declaration            ::= attributes? SET  accessor_body ; 

accessor_body                       ::= block |
                                     SEMICOLON ; 

event_declaration                   ::= attributes? event_modifiers? EVENT  type variable_declarators SEMICOLON  |
                                     attributes? event_modifiers? EVENT  type member_name LBRACE  event_accessor_declarations RBRACE  ; 

event_modifiers                     ::= event_modifier |
                                     event_modifiers event_modifier ; 

event_modifier                      ::= NEW  
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE  |
                                     STATIC  |
                                     VIRTUAL  |
                                     SEALED  |
                                     ABSTRACT  |
                                     OVERRIDE  |
                                     EXTERN ; 

event_accessor_declarations         ::= add_accessor_declaration remove_accessor_declaration |
                                     remove_accessor_declaration add_accessor_declaration ; 

add_accessor_declaration            ::= attributes? ADD  block ; 

remove_accessor_declaration         ::= attributes? REMOVE  block ; 

indexer_declaration                 ::= attributes? indexer_modifiers? indexer_declarator LBRACE  accessor_declarations RBRACE ; 

indexer_modifiers                   ::= indexer_modifier |
                                     indexer_modifiers indexer_modifier ; 

indexer_modifier                    ::= NEW |
                                     PUBLIC |
                                     PROTECTED  |
                                     PRIVATE  |
                                     INTERNAL  |
                                     VIRTUAL  |
                                     SEALED  |
                                     OVERRIDE  |
                                     ABSTRACT  |
                                     EXTERN  ; 

indexer_declarator                  ::= type THIS  LBRACKET  formal_parameter_list RBRACKET  |
                                     type interface_type DOT  THIS  LBRACKET  formal_parameter_list RBRACKET  ; 

operator_declaration                ::= attributes? operator_modifiers operator_declarator operator_body ; 

operator_modifiers                  ::= operator_modifier |
                                     operator_modifiers operator_modifier ; 

operator_modifier                   ::= PUBLIC  |
                                     STATIC  |
                                     EXTERN  ; 

operator_declarator                 ::= unary_operator_declarator |
                                     binary_operator_declarator |
                                     conversion_operator_declarator ; 

unary_operator_declarator           ::= type OPERATOR  overloadable_unary_operator LPAREN  type IDENTIFIER  RPAREN  ; 

overloadable_unary_operator         ::= ADD_OP  |
                                     SUB_OP  |
                                     NOT_OP  |
                                     TILDE  |
                                     INCREMENT  |
                                     DECREMENT  |
                                     BOOLEAN_LITERAL ; 

binary_operator_declarator          ::= type OPERATOR  overloadable_binary_operator LPAREN  type IDENTIFIER  COMMA  type IDENTIFIER  RPAREN  ; 

overloadable_binary_operator        ::= ADD_OP  |
                                     SUB_OP |
                                     MUL_OP  |
                                     DIV_OP  |
                                     MOD_OP  |
                                     AND_OP  |
                                     OR_OP  |
                                     XOR_OP  |
                                     LSHIFT_OP  |
                                     RSHIFT_OP  |
                                     EQUALITY_OP  |
                                     NEQUALITY_OP  |
                                     GREATERTHAN_OP  |
                                     LESSTHAN_OP  |
                                     GREATERTHANEQ_OP  |
                                     LESSTHANEQ_OP ; 

conversion_operator_declarator      ::= IMPLICIT  OPERATOR  type LPAREN  type IDENTIFIER  RPAREN  |
                                     EXPLICIT  OPERATOR  type LPAREN  type IDENTIFIER  RPAREN  ; 

operator_body                       ::= block |
                                     SEMICOLON  ; 

constructor_declaration             ::= attributes? constructor_modifiers? constructor_declarator constructor_body ; 

constructor_modifiers               ::= constructor_modifier |
                                     constructor_modifiers constructor_modifier ; 

constructor_modifier                ::= PUBLIC |
                                     PROTECTED |
                                     INTERNAL  |
                                     PRIVATE  |
                                     EXTERN ; 

constructor_declarator              ::= IDENTIFIER  LPAREN  formal_parameter_list? RPAREN  constructor_initializer? ; 

constructor_initializer             ::= COLON  BASE  LPAREN  argument_list? RPAREN  |
                                     COLON  THIS  LPAREN  argument_list? RPAREN  ; 

constructor_body                    ::= block |
                                     SEMICOLON  ; 

static_constructor_declaration      ::= attributes? static_constructor_modifiers IDENTIFIER  LPAREN  RPAREN  static_constructor_body ; 

static_constructor_modifiers        ::= EXTERN?  STATIC  |
                                     STATIC  EXTERN?  ; 

static_constructor_body             ::= block |
                                     SEMICOLON  ; 

destructor_declaration              ::= attributes? EXTERN?  TILDE  IDENTIFIER  LPAREN  RPAREN  destructor_body ; 

destructor_body                     ::= block |
                                     SEMICOLON  ; // A.2.8 Structs


struct_declaration                  ::= attributes? struct_modifiers? STRUCT  IDENTIFIER  struct_interfaces? struct_body SEMICOLON? ; 

struct_modifiers                    ::= struct_modifier |
                                     struct_modifiers struct_modifier ; 

struct_modifier                     ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE ; 

struct_interfaces                   ::= COLON  interface_type_list ; 

struct_body                         ::= LBRACE  struct_member_declarations? RBRACE  ; 

struct_member_declarations          ::= struct_member_declaration |
                                     struct_member_declarations struct_member_declaration ; 

struct_member_declaration           ::= constant_declaration |
                                     field_declaration |
                                     method_declaration |
                                     property_declaration |
                                     event_declaration |
                                     indexer_declaration |
                                     operator_declaration |
                                     constructor_declaration |
                                     static_constructor_declaration |
                                     type_declaration ; // A.2.9 Arrays


array_type                          ::= non_array_type rank_specifiers ; 

non_array_type                      ::= type ; 

rank_specifiers                     ::= rank_specifier |
                                     rank_specifiers rank_specifier ; 

rank_specifier                      ::= LBRACKET  dim_separators? RBRACKET  ; 

dim_separators                      ::= COMMA  |
                                     dim_separators COMMA ; 

array_initializer                   ::= LBRACE  variable_initializer_list? RBRACE  |
                                     LBRACE  variable_initializer_list COMMA  RBRACE ; 

variable_initializer_list           ::= variable_initializer |
                                     variable_initializer_list COMMA  variable_initializer ; // A.2.10 Interfaces


interface_declaration               ::= attributes? interface_modifiers? INTERFACE  IDENTIFIER  interface_base? interface_body SEMICOLON? ; 

interface_modifiers                 ::= interface_modifier |
                                     interface_modifiers interface_modifier ; 

interface_modifier                  ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE ; 

interface_base                      ::= COLON  interface_type_list ; 

interface_body                      ::= LBRACE  interface_member_declarations? RBRACE  ; 

interface_member_declarations       ::= interface_member_declaration |
                                     interface_member_declarations interface_member_declaration ; 

interface_member_declaration        ::= interface_method_declaration |
                                     interface_property_declaration |
                                     interface_event_declaration |
                                     interface_indexer_declaration ; 

interface_method_declaration        ::= attributes? NEW?  return_type IDENTIFIER  LPAREN  formal_parameter_list? RPAREN  SEMICOLON ; 

interface_property_declaration      ::= attributes? NEW?  type IDENTIFIER  LBRACE  interface_accessors RBRACE ; 

interface_accessors                 ::= attributes? GET  SEMICOLON  |
                                     attributes? SET  SEMICOLON  |
                                     attributes? GET  SEMICOLON  attributes? SET  SEMICOLON  |
                                     attributes? SET  SEMICOLON  attributes? GET  SEMICOLON ; 

interface_event_declaration         ::= attributes? NEW?  EVENT  type IDENTIFIER  SEMICOLON ; 

interface_indexer_declaration       ::= attributes? NEW?  type THIS  LBRACKET  formal_parameter_list RBRACKET  LBRACE  interface_accessors RBRACE  ; // A.2.11 Enums


enum_declaration                    ::= attributes? enum_modifiers? ENUM  IDENTIFIER  enum_base? enum_body SEMICOLON? ; 

enum_base                           ::=  COLON  integral_type ; 

enum_body                           ::= LBRACE  enum_member_declarations? RBRACE  |
                                     LBRACE  enum_member_declarations COMMA  RBRACE  ; 

enum_modifiers                      ::= enum_modifier |
                                     enum_modifiers enum_modifier ; 

enum_modifier                       ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE ; 

enum_member_declarations            ::= enum_member_declaration |
                                     enum_member_declarations COMMA  enum_member_declaration ; 

enum_member_declaration             ::= attributes? IDENTIFIER  |
                                     attributes? IDENTIFIER  DIRASSIGN  constant_expression ; // A.2.12 Delegates


delegate_declaration                ::= attributes? delegate_modifiers? DELEGATE  return_type IDENTIFIER  LPAREN  formal_parameter_list? RPAREN  SEMICOLON ; 

delegate_modifiers                  ::= delegate_modifier |
                                     delegate_modifiers delegate_modifier ; 

delegate_modifier                   ::= NEW  |
                                     PUBLIC  |
                                     PROTECTED  |
                                     INTERNAL  |
                                     PRIVATE ; // A.2.13 Attributes


global_attributes                   ::= global_attribute_sections ; 

global_attribute_sections           ::= global_attribute_section |
                                     global_attribute_sections global_attribute_section ; 

global_attribute_section            ::= LBRACKET  global_attribute_target_specifier attribute_list RBRACKET  |
                                     LBRACKET  global_attribute_target_specifier attribute_list COMMA  RBRACKET ; 

global_attribute_target_specifier   ::= global_attribute_target COLON  ; (*GLOBAL_ATTRIBUTE_TARGET ::= new_line_opt
  'assembly' |
  'module' ;*)
// hack for lexer


global_attribute_target             ::= ASSEMBLY  | MODULE ; 

attributes                          ::= attribute_sections ; 

attribute_sections                  ::= attribute_section |
                                     attribute_sections attribute_section ; 

attribute_section                   ::= LBRACKET  attribute_target_specifier? attribute_list RBRACKET  |
                                     LBRACKET  attribute_target_specifier? attribute_list COMMA  RBRACKET ; 

attribute_target_specifier          ::= attribute_target COLON  ; (*ATTRIBUTE_TARGET ::= new_line_opt
  'field' |
  'event' |
  'method' |
  'param' |
  'property' |
  'return' |
  'type' ; *)
// Hack to allow keywords as IDENTIFIERs


attribute_target                    ::= FIELD  | EVENT  | METHOD  | PARAM  | PROPERTY  | RETURN  | TYPE ; 

attribute_list                      ::= attribute |
                                     attribute_list COMMA  attribute ; 

attribute                           ::= attribute_name attribute_arguments? ; 

attribute_name                      ::= type_name ; 

attribute_arguments                 ::=  LPAREN  positional_argument_list? RPAREN  |
                                     LPAREN  positional_argument_list COMMA  named_argument_list RPAREN  |
                                     LPAREN  named_argument_list RPAREN  ; 

positional_argument_list            ::= positional_argument |
                                     positional_argument_list COMMA  positional_argument ; 

positional_argument                 ::= attribute_argument_expression ; 

named_argument_list                 ::= named_argument |
                                     named_argument_list COMMA  named_argument ; 

named_argument                      ::= IDENTIFIER  DIRASSIGN  attribute_argument_expression ; 

attribute_argument_expression       ::= expression ; 

literal                             ::= BOOLEAN_LITERAL  |
                                     INTEGER_LITERAL  |
                                     REAL_LITERAL  |
                                     CHARACTER_LITERAL  |
                                     STRING_LITERAL  |
                                     NULL_LITERAL ; 

new_line_opt ::= `\r | `\n | `\r`\n | # ;

// Character Level Lexer
ADD ::= new_line_opt `a`d`d ;
REMOVE ::= new_line_opt `r`e`m`o`v`e ;
GET ::= new_line_opt `g`e`t ;
SET ::= new_line_opt `s`e`t ;
ASSEMBLY ::= new_line_opt `a`s`s`e`m`b`l`y ;
MODULE ::= new_line_opt `m`o`d`u`l`e ;
FIELD ::= new_line_opt `f`i`e`l`d ;
PARAM ::= new_line_opt `p`a`r`a`m ;
PROPERTY ::= new_line_opt `p`r`o`p`e`r`t`y ;
TYPE ::= new_line_opt `t`y`p`e ;

ABSTRACT ::= new_line_opt `a`b`s`t`r`a`c`t ;
AS ::= new_line_opt `a`s ;
BASE ::= new_line_opt `b`a`s`e ;
BOOL ::= new_line_opt `b`o`o`l ;
BREAK ::= new_line_opt `b`r`e`a`k ;
BYTE ::= new_line_opt `b`y`t`e ;
CASE ::= new_line_opt `c`a`s`e ;
CATCH ::= new_line_opt `c`a`t`c`h ;
CHAR ::= new_line_opt `c`h`a`r ;
CHECKED ::= new_line_opt `c`h`e`c`k`e`d ;
CLASS ::= new_line_opt `c`l`a`s`s ;
CONST ::= new_line_opt `c`o`n`s`t ;
CONTINUE ::= new_line_opt `c`o`n`t`i`n`u`e ;
DECIMAL ::= new_line_opt `d`e`c`i`m`a`l ;
DEFAULT ::= new_line_opt `d`e`f`a`u`l`t ;
DELEGATE ::= new_line_opt `d`e`l`e`g`a`t`e;
DO ::= new_line_opt `d`o ;
DOUBLE ::= new_line_opt `d`o`u`b`l`e ;
ELSE ::= new_line_opt `e`l`s`e ;
ENUM ::= new_line_opt `e`n`u`m ;
EVENT ::= new_line_opt `e`v`e`n`t ;
EXPLICIT ::= new_line_opt `e`x`p`l`i`c`i`t ;
EXTERN ::= new_line_opt `e`x`t`e`r`n ;
FALSE ::= new_line_opt `f`a`l`s`e ;
FINALLY ::= new_line_opt `f`i`n`a`l`l`y ;
FIXED ::= new_line_opt `f`i`x`e`d ;
FLOAT ::= new_line_opt `f`l`o`a`t ;
FOR ::= new_line_opt `f`o`r ;
FOREACH ::= new_line_opt `f`o`r`e`a`c`h ;
GOTO ::= new_line_opt `g`o`t`o ;
IF ::= new_line_opt `i`f ;
IMPLICIT ::= new_line_opt `i`m`p`l`i`c`i`t ;
IN ::= new_line_opt `i`n ;
INT ::= new_line_opt `i`n`t ;
INTERFACE ::= new_line_opt `i`n`t`e`r`f`a`c`e ;
INTERNAL ::= new_line_opt `i`n`t`e`r`n`a`l ;
IS ::= new_line_opt `i`s ;
LOCK ::= new_line_opt `l`o`c`k ;
LONG ::= new_line_opt `l`o`n`g ;
NAMESPACE ::= new_line_opt `n`a`m`e`s`p`a`c`e ;
NEW ::= new_line_opt `n`e`w ;
OBJECT ::= new_line_opt `o`b`j`e`c`t ;
OPERATOR ::= new_line_opt `o`p`e`r`a`t`o`r ;
OUT ::= new_line_opt `o`u`t ;
OVERRIDE ::= new_line_opt `o`v`e`r`r`i`d`e ;
PARAMS ::= new_line_opt `p`a`r`a`m`s ;
PRIVATE ::= new_line_opt `p`r`i`v`a`t`e ;
PROTECTED ::= new_line_opt `p`r`o`t`e`c`t`e`d ;
PUBLIC ::= new_line_opt `p`u`b`l`i`c ;
READONLY ::= new_line_opt `r`e`a`d`o`n`l`y ;
REF ::= new_line_opt `r`e`f ;
RETURN ::= new_line_opt `r`e`t`u`r`n ;
SBYTE ::= new_line_opt `s`b`y`t`e ;
SEALED ::= new_line_opt `s`e`a`l`e`d ;
SHORT ::= new_line_opt `s`h`o`r`t ;
SIZEOF ::= new_line_opt `s`i`z`e`o`f ;
STACKALLOC ::= new_line_opt `s`t`a`c`k`a`l`l`o`c ;
STATIC ::= new_line_opt `s`t`a`t`i`c ;
STRING ::= new_line_opt `s`t`r`i`n`g ;
STRUCT ::= new_line_opt `s`t`r`u`c`t ;
SWITCH ::= new_line_opt `s`w`i`t`c`h ;
THIS ::= new_line_opt `t`h`i`s ;
THROW ::= new_line_opt `t`h`r`o`w ;
TRUE ::= new_line_opt `t`r`u`e ;
TRY ::= new_line_opt `t`r`y ;
TYPEOF ::= new_line_opt `t`y`p`e`o`f ;
UINT ::= new_line_opt `u`i`n`t ;
ULONG ::= new_line_opt `u`l`o`n`g ;
UNCHECKED ::= new_line_opt `u`n`c`h`e`c`k`e`d ;
UNSAFE ::= new_line_opt `u`n`s`a`f`e ;
USHORT ::= new_line_opt `u`s`h`o`r`t ;
USING ::= new_line_opt `u`s`i`n`g ;
VIRTUAL ::= new_line_opt `v`i`r`t`u`a`l ;
VOID ::= new_line_opt `v`o`i`d ;
VOLATILE ::= new_line_opt `v`o`l`a`t`i`l`e ;
WHILE ::= new_line_opt `w`h`i`l`e ;
METHOD ::= new_line_opt `m`e`t`h`o`d ;

//WHITESPACE ::= new_line_opt `  | `\t | `\v | `\f ;

//COMMENT ::= new_line_opt `/`/ input_character* | `/`* (not_asterisk | `*+ not_slash)* `*+ `/ ;

input_character ::=
  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `" | `# | `$ | `% | `& 
  | `' | `( | `) | `* | `+ | `, | `- | `. | `/ | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `\\ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ ;
  
new_line_character ::= `\r | `\n ;

not_asterisk ::= 
  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `" | `# | `$ | `% | `& 
  | `' | `( | `) | `\r | `\n | `+ | `, | `- | `. | `/ | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `\\ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ ;
  
not_slash ::=
  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `" | `# | `$ | `% | `& 
  | `' | `( | `) | `\r | `\n | `+ | `, | `- | `. | `* | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `\\ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ ;
  
unicode_character_escape_sequence ::=
  `\\`u hex_digit hex_digit hex_digit hex_digit
  | `\\`U hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit ;
  
IDENTIFIER ::= new_line_opt (letter_character | `_) identifier_part_character* | new_line_opt `@ (letter_character | `_) identifier_part_character* ;

// Can I filter keywords?

letter_character ::= 
  `A | `B | `C | `D | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P 
  | `Q | `R | `S | `T | `U | `V | `W | `X | `Y | `Z | `a | `b | `c | `d | `e 
  | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q | `r | `s | `t 
  | `u | `v | `w | `x | `y | `z ;
  
identifier_part_character ::= 
  `A | `B | `C | `D | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P 
  | `Q | `R | `S | `T | `U | `V | `W | `X | `Y | `Z | `a | `b | `c | `d | `e 
  | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q | `r | `s | `t 
  | `u | `v | `w | `x | `y | `z | `0 | `1 | `2 | `3 | `4 | `5 | `6 | `7 | `8 
  | `9 | `_ | unicode_character_escape_sequence;

BOOLEAN_LITERAL ::= new_line_opt `t`r`u`e | new_line_opt `f`a`l`s`e ;

INTEGER_LITERAL ::= new_line_opt decimal_digit+ integer_type_suffix? | new_line_opt `0`x hex_digit+ integer_type_suffix?
  | new_line_opt `0`X hex_digit+ integer_type_suffix? ;

decimal_digit ::= `0 | `1 | `2 | `3 | `4 | `5 | `6 | `7 | `8 | `9 ;

integer_type_suffix ::= `U | `u | `L | `l | `U`L | `U`l | `u`L | `u`l | `L`U | `L`u
  | `l`U | `l`u ;
  
hex_digit ::=
  `0 | `1 | `2 | `3 | `4 | `5 | `6 | `7 | `8 | `9 | `A | `B | `C | `D | `E | `F
  | `a | `b | `c | `d | `e | `f ;
  
REAL_LITERAL ::= new_line_opt decimal_digit+ `. decimal_digit+ exponent_part? real_type_suffix?
  | new_line_opt `. decimal_digit+ exponent_part? real_type_suffix?
  | new_line_opt decimal_digit+ exponent_part real_type_suffix?
  | new_line_opt decimal_digit+ real_type_suffix ;
  
exponent_part ::=
  `e (`+ | `-)? decimal_digit+
  | `E (`+ | `-)? decimal_digit+ ;

real_type_suffix ::= `F | `f | `D | `d | `M | `m ;

CHARACTER_LITERAL ::= new_line_opt `' character `' ;

character ::= single_character | simple_escape_sequence | hexadecimal_escape_sequence
  | unicode_character_escape_sequence ;
  
single_character ::=  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `" | `# | `$ | `% | `& 
  | `( | `) | `* | `+ | `, | `- | `. | `/ | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ ;

simple_escape_sequence ::= `\\`' | `\\ `" | `\\`\\ | `\\`0 | `\\`a | `\\`b | `\\`f | `\\`n
  | `\\`n | `\\`r | `\\`t | `\\`v ;
  
hexadecimal_escape_sequence ::= `\\`x hex_digit hex_digit? hex_digit? hex_digit? ;

STRING_LITERAL ::= new_line_opt `" regular_string_literal_character* `" | new_line_opt `@ `" (single_verbatim_string_literal_character | `" `")* `" ;

regular_string_literal_character ::= single_regular_string_literal_character
  | simple_escape_sequence
  | hexadecimal_escape_sequence
  | unicode_character_escape_sequence;
  
single_regular_string_literal_character ::=
  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `# | `$ | `% | `& 
  | `' | `( | `) | `* | `+ | `, | `- | `. | `/ | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ ;
  
single_verbatim_string_literal_character ::=
  `\0 | `\a | `\b | `\t | `\v | `\f | `\e | `  | `! | `# | `$ | `% | `& 
  | `' | `( | `) | `* | `+ | `, | `- | `. | `/ | `0 | `1 | `2 | `3 | `4 | `5
  | `6 | `7 | `8 | `9 | `: | `; | `< | `= | `> | `? | `@ | `A | `B | `C | `D
  | `E | `F | `G | `H | `I | `J | `K | `L | `M | `N | `O | `P | `Q | `R | `S
  | `T | `U | `V | `W | `X | `Y | `Z | `[ | `\\ | `] | `^ | `_ | `` | `a | `b
  | `c | `d | `e | `f | `g | `h | `i | `j | `k | `l | `m | `n | `o | `p | `q 
  | `r | `s | `t | `u | `v | `w | `x | `y | `z | `{ | `| | `} | `~ | `\n | `\r ;

NULL_LITERAL ::= new_line_opt `n`u`l`l;

LESSTHAN_OP ::= new_line_opt `< ;

GREATERTHAN_OP ::= new_line_opt `> ;

LESSTHANEQ_OP ::= new_line_opt `<`= ;

GREATERTHANEQ_OP ::= new_line_opt `>`= ;

EQUALITY_OP ::= new_line_opt `=`=;
NEQUALITY_OP ::= new_line_opt `!`= ;

ADD_OP ::= new_line_opt `+ ;

SUB_OP ::= new_line_opt `- ;

MUL_OP ::= new_line_opt `*  ;

DIV_OP ::= new_line_opt `/ ;

MOD_OP ::= new_line_opt `% ;

AND_OP ::= new_line_opt `& ;

XOR_OP ::= new_line_opt `^ ;

OR_OP ::= new_line_opt `| ;

LSHIFT_OP ::= new_line_opt `<`< ;

RSHIFT_OP ::= new_line_opt  `>`> ;

CONDAND_OP ::= new_line_opt `&`& ;

CONDOR_OP ::= new_line_opt `|`| ;

NOT_OP ::= new_line_opt `! ;

TILDE ::= new_line_opt `~ ;

DOT ::= new_line_opt `. ;

COMMA ::= new_line_opt `, ;

LPAREN ::= new_line_opt `( ;

RPAREN ::= new_line_opt `) ;

LBRACKET ::= new_line_opt `[ ;

RBRACKET ::= new_line_opt `] ;

LBRACE ::= new_line_opt `{ ;

RBRACE ::= new_line_opt `} ;

INCREMENT ::= new_line_opt `+`+ ;

DECREMENT ::= new_line_opt `-`- ;

QUESTION ::= new_line_opt `? ;

COLON ::= new_line_opt `: ;

SEMICOLON ::= new_line_opt `; ;

DIRASSIGN ::= new_line_opt `= ;

ADDASSIGN ::= new_line_opt `+`= ;

SUBASSIGN ::= new_line_opt `-`= ;

MULASSIGN ::= new_line_opt `*`= ;

DIVASSIGN ::= new_line_opt `/`= ;

MODASSIGN ::= new_line_opt `%`= ;

ANDASSIGN ::= new_line_opt `&`= ;

ORASSIGN ::= new_line_opt `|`= ;

XORASSIGN ::= new_line_opt `^`= ;

LSHIFTASSIGN ::= new_line_opt `<`<`= ;

RSHIFTASSIGN ::= new_line_opt `>`>`= ;